---
layout: single
published: true
title:  "JAVA 언어 : Couse1. Part4 객체지향 프로그래밍 설계하기(Feat. 시그니처 백엔드 강의)"
---

## 목차
- [Part4. 객체지향 프로그래밍 설계하기](#part4-객체지향-프로그래밍-설계하기)
  * [Ch01. 자바에서 상속이란?](#ch01-자바에서-상속이란)
  * [Ch02. 상속관계에서 객체생성 및 Override](#ch02-상속관계에서-객체생성-및-override)
  * [Ch03. 객체 형변환(Object Casting)](#ch03-객체-형변환object-casting)
  * [Ch04. 다형성(Polymorphism)과 활용](#ch04-다형성polymorphism과-활용)
  * [Ch05. 추상클래스와 인터페이스의 등장](#ch05-추상클래스와-인터페이스의-등장)
  * [Ch06. 자바 최상위 클래스 Object](#ch06-자바-최상위-클래스-object)



## Part4. 객체지향 프로그래밍 설계하기

### Ch01. 자바에서 상속이란?

* 수평적 구조와 수직적 구조의 설계 방법
  - 필요한 이유 : 자식은 부모것들 사용가능(무조건 전부는 아님)
  - 상속 : 부모가 자식들에게 자식의 것 사용하게 허락
    > 객체 설계시 비슷한 클래스는 "중복요소"가 발생
    > 수평적 구조 코드의 중복/ 새로운 요구사항 발생시 유지보수가 어려움/ 확장성이 떨어짐
  - 수직적 구조 = 계층화 = 상속 = 클래스와 클래스의 관계 설계 < extends

    
* 클래스 계층화 할때 장점
  - 상속 : 클래스 계층화("is a kind of") ~의 종류
    > 코드 중복부분 최소화 / 유지보수가 쉬워짐 확장성이 좋아짐/VS코드 복잡

* 메모리를 통한 상속 이해(상태정보 재활용)
  - Super class(상위,부모) : 일반화 추상화,개념화 포괄적 ex) 사원 >> 상태변수에 `protected` 를 많이 사용(하위클래스만 접근 허용)
  - Sub class(하위,자식,파생) : 구체화, 세분화 > `super();` 상위 클래스의 생성자를 호출 > super가 없어도 생략되있는거임
  - 하위가 상위 재활용 가능(상위클래스에 접근하여 사용)
  - "하위" extends "상위" 가 상속관계 만듬(계층화)
  - 상속 관계에서는 "부모"가 만들어져야 "자식"을 만들어야됨 (부모없는 자식은 없음)
  - "Object" 라는 클래스가 가장 최상위 클래스 > 클래스 만들면 무조건 기본적으로 상속됨. (extends Object)가 생략되잇음

```java
public class Employee{
public Employee(){
    super(); //상위 생성자 호출(최상위가 Object가 default)
}
}

public class RempVO extends Employee{
    public RempVO(){
        super(); //생략가능 new Employee(); 와 비슷한 역할임 Employee 생성자가 호출됨
}
}
```

<details>
  <summary>
    상속 예제 : 상속관계 (사원과 일반사원)를 이용하여 사원정보 저장 및 출력
  </summary>
<div markdown="1">
  <br>
```java
  public class Employee {
    protected String name;
    protected int age;
    protected String  phone;
    protected  String empDate;
    protected  String dept;
    protected boolean marriage;

    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phone='" + phone + '\'' +
                ", empDate='" + empDate + '\'' +
                ", dept='" + dept + '\'' +
                ", marriage=" + marriage +
                '}';
    }
    public Employee(){
        super(); // 상위클래스의 생성자를 호출 > new Object();의미임

    }
}
```

```java
public class RempVO extends Employee{
    public RempVO(){
        super();
    }
}

```


```java
public class EmployeeTest {
    public static void main(String[] args) {
        //[일반사원] 한명의 객체를 생성하고 데이터를 저장후 출력하세요.
        RempVO vo=new RempVO();\
        vo.name="홍길동";
        vo.age=50;
        vo.phone="010-1111-1111";
        vo.empDate="2022-10-10";
        vo.dept="홍보부";
        vo.marriage=true;
        //출력
        System.out.println(vo);

    }

}
```

  
</div>
</details>

* 상속관계에서 객체 생성
  : 하위 클래스에서도 생성자를 이용해 초기화 이용 가능

  - 그러나 초기화는 해당하는 객체 자신이 하는 것이 바람직하다.
  - 클래스 설계시 상위클래스도 멤버변수는 전부 "private" 이 바람직
  - 그럼 > private일때 자식이 부모한테 super();(생성자 호출)
  - 부모가 값을 받아서 생성해주기(super 생성자로-상위클래스 생성자)
 
 <details>
  <summary>
    부모가 초기화, 자식이 요청 예제
  </summary>
<div markdown="1">
  <br>

  
```java
package fc.java.part4;

public class Employee {
    private String name;
    private int age;
    private String  phone;
    private  String empDate;
    private  String dept;
    private boolean marriage;

    public Employee(String name, int age, String phone, String empDate, String dept, boolean marriage) {
        this.name = name;
        this.age = age;
        this.phone = phone;
        this.empDate = empDate;
        this.dept = dept;
        this.marriage = marriage;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phone='" + phone + '\'' +
                ", empDate='" + empDate + '\'' +
                ", dept='" + dept + '\'' +
                ", marriage=" + marriage +
                '}';
    }

    public Employee(){
        super(); // 상위클래스의 생성자를 호출 > new Object();의미임

    }

}


```
```java
package fc.java.part4;

public class RempVO extends Employee{
    public RempVO(){
        super();
    }
    public RempVO(String name, int age, String phone, String empDate, String dept, boolean marriage) {

        super(name,age,phone,empDate,dept,marriage);
    }
}

```
```java
package fc.java.part4;

public class EmployeeTest {
    public static void main(String[] args) {
        //[일반사원] 한명의 객체를 생성하고 데이터를 저장후 출력하세요.
        RempVO vo=new RempVO("홍길동",35,"010-1111-1111","2022-11-10","기획부",false);

        //출력
        System.out.println(vo);

    }

}


```
</div>
</details>




### Ch02. 상속관계에서 객체생성 및 Override 

* 동적측면에서 클래스 설계하기
  - 상속구조를 왜 사용할까(동적측면에서)
  - 설계한 사람과 사용자 입장이 다를때 > class파일만 줌.
  - 그럼 도구클래스 써먹을때 써먹는게 제한적. (어떤 동작있는지 모름) > 설계를 잘 해줘야됨 > 상속을 써야한다
  - 별도의 구동시킬 수 있는 클래스를 주면됨(인터페이스 역할-리모컨같은역할)

> 상속은 부모클래스를 잘 활용해야됨 > 부모통해 자식들 활용

* 상속관계에서 객체 생성 방법
  - 업캐스팅(부모가 자식을 가리키는 객체생성 방법) 이 가능
    ` Animal x= new Dog();
      Animal x= new Cat();`
  - 부모가 자식을 가르킴. 자식의 타입을 받아옴
  - 상속되면 Dog메모리 + Animal 메모리-자식이 생성한 객체 > 둘다 Dog사용가능

* 상속 체이닝과 super
    - 상속 체이닝 - (나보다 부모가 먼저 생성) 맨위부터 부모클래스부터 가장 자식까지 연결되는 구조
    - super() -  상위 클래스의 생성자를 호출함. 생성자 메서드에서 가장 첫 문장에 사용해야됨***  
      상위클래스의 기본생성자를 호출하는 super는 생략되어있음

  > super는 자식 클래스의 생성자에 첫머리에 와야됨! 

* 메서드의 재정의 Override 란?
    - 자식입장에서 수선해서 재정의해서 쓰는것. 상속관계에서 하위클래스가 동작을 재정의함(기능추가, 변경)
    - 동적 바인딩을 하게됨 > 실행시점에서 사용될 메서드가 결정되는 바인딩 : 자식한테 같은 메서드가 있으면 그걸 실행
      > 컴파일 시점에서는 부모건데, 실행할때 자식이 재정의를 했으면 자식 것을 실행함.
      > 부모 메서드는 그림자(무시)가됨..
    

### Ch03. 객체 형변환(Object Casting)





### Ch04. 다형성(Polymorphism)과 활용




### Ch05. 추상클래스와 인터페이스의 등장




### Ch06. 자바 최상위 클래스 Object

