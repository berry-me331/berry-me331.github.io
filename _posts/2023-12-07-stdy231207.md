---
layout: single
published: true
title:  "JAVA 언어 : Couse1. Part4 객체지향 프로그래밍 설계하기(Feat. 시그니처 백엔드 강의)"
---

## 목차
- [Part4. 객체지향 프로그래밍 설계하기](#part4-객체지향-프로그래밍-설계하기)
  * [Ch01. 자바에서 상속이란?](#ch01-자바에서-상속이란)
  * [Ch02. 상속관계에서 객체생성 및 Override](#ch02-상속관계에서-객체생성-및-override)
  * [Ch03. 객체 형변환(Object Casting)](#ch03-객체-형변환object-casting)
  * [Ch04. 다형성(Polymorphism)과 활용](#ch04-다형성polymorphism과-활용)
  * [Ch05. 추상클래스와 인터페이스의 등장](#ch05-추상클래스와-인터페이스의-등장)
  * [Ch06. 자바 최상위 클래스 Object](#ch06-자바-최상위-클래스-object)



## Part4. 객체지향 프로그래밍 설계하기

### Ch01. 자바에서 상속이란?

* 수평적 구조와 수직적 구조의 설계 방법
  - 필요한 이유 : 자식은 부모것들 사용가능(무조건 전부는 아님)
  - 상속 : 부모가 자식들에게 자식의 것 사용하게 허락
    > 객체 설계시 비슷한 클래스는 "중복요소"가 발생
    > 수평적 구조 코드의 중복/ 새로운 요구사항 발생시 유지보수가 어려움/ 확장성이 떨어짐
  - 수직적 구조 = 계층화 = 상속 = 클래스와 클래스의 관계 설계 < extends

    
* 클래스 계층화 할때 장점
  - 상속 : 클래스 계층화("is a kind of") ~의 종류
    > 코드 중복부분 최소화 / 유지보수가 쉬워짐 확장성이 좋아짐/VS코드 복잡

* 메모리를 통한 상속 이해(상태정보 재활용)
  - Super class(상위,부모) : 일반화 추상화,개념화 포괄적 ex) 사원 >> 상태변수에 `protected` 를 많이 사용(하위클래스만 접근 허용)
  - Sub class(하위,자식,파생) : 구체화, 세분화 > `super();` 상위 클래스의 생성자를 호출 > super가 없어도 생략되있는거임
  - 하위가 상위 재활용 가능(상위클래스에 접근하여 사용)
  - "하위" extends "상위" 가 상속관계 만듬(계층화)
  - 상속 관계에서는 "부모"가 만들어져야 "자식"을 만들어야됨 (부모없는 자식은 없음)
  - "Object" 라는 클래스가 가장 최상위 클래스 > 클래스 만들면 무조건 기본적으로 상속됨. (extends Object)가 생략되잇음

```java
public class Employee{
public Employee(){
    super(); //상위 생성자 호출(최상위가 Object가 default)
}
}

public class RempVO extends Employee{
    public RempVO(){
        super(); //생략가능 new Employee(); 와 비슷한 역할임 Employee 생성자가 호출됨
}
}
```

<details>
  <summary>
    상속 예제 : 상속관계 (사원과 일반사원)를 이용하여 사원정보 저장 및 출력
  </summary>
<div markdown="1">
  <br>
```java
  public class Employee {
    protected String name;
    protected int age;
    protected String  phone;
    protected  String empDate;
    protected  String dept;
    protected boolean marriage;

    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phone='" + phone + '\'' +
                ", empDate='" + empDate + '\'' +
                ", dept='" + dept + '\'' +
                ", marriage=" + marriage +
                '}';
    }
    public Employee(){
        super(); // 상위클래스의 생성자를 호출 > new Object();의미임

    }
}
```

```java
public class RempVO extends Employee{
    public RempVO(){
        super();
    }
}

```


```java
public class EmployeeTest {
    public static void main(String[] args) {
        //[일반사원] 한명의 객체를 생성하고 데이터를 저장후 출력하세요.
        RempVO vo=new RempVO();\
        vo.name="홍길동";
        vo.age=50;
        vo.phone="010-1111-1111";
        vo.empDate="2022-10-10";
        vo.dept="홍보부";
        vo.marriage=true;
        //출력
        System.out.println(vo);

    }

}
```

  
</div>
</details>

* 상속관계에서 객체 생성
  : 하위 클래스에서도 생성자를 이용해 초기화 이용 가능

  - 그러나 초기화는 해당하는 객체 자신이 하는 것이 바람직하다.
  - 클래스 설계시 상위클래스도 멤버변수는 전부 "private" 이 바람직
  - 그럼 > private일때 자식이 부모한테 super();(생성자 호출)
  - 부모가 값을 받아서 생성해주기(super 생성자로-상위클래스 생성자)
 
 <details>
  <summary>
    부모가 초기화, 자식이 요청 예제
  </summary>
<div markdown="1">
  <br>

  
```java
package fc.java.part4;

public class Employee {
    private String name;
    private int age;
    private String  phone;
    private  String empDate;
    private  String dept;
    private boolean marriage;

    public Employee(String name, int age, String phone, String empDate, String dept, boolean marriage) {
        this.name = name;
        this.age = age;
        this.phone = phone;
        this.empDate = empDate;
        this.dept = dept;
        this.marriage = marriage;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phone='" + phone + '\'' +
                ", empDate='" + empDate + '\'' +
                ", dept='" + dept + '\'' +
                ", marriage=" + marriage +
                '}';
    }

    public Employee(){
        super(); // 상위클래스의 생성자를 호출 > new Object();의미임

    }

}


```
```java
package fc.java.part4;

public class RempVO extends Employee{
    public RempVO(){
        super();
    }
    public RempVO(String name, int age, String phone, String empDate, String dept, boolean marriage) {

        super(name,age,phone,empDate,dept,marriage);
    }
}

```
```java
package fc.java.part4;

public class EmployeeTest {
    public static void main(String[] args) {
        //[일반사원] 한명의 객체를 생성하고 데이터를 저장후 출력하세요.
        RempVO vo=new RempVO("홍길동",35,"010-1111-1111","2022-11-10","기획부",false);

        //출력
        System.out.println(vo);

    }

}


```
</div>
</details>




### Ch02. 상속관계에서 객체생성 및 Override 

* 동적측면에서 클래스 설계하기
  - 상속구조를 왜 사용할까(동적측면에서)
  - 설계한 사람과 사용자 입장이 다를때 > class파일만 줌.
  - 그럼 도구클래스 써먹을때 써먹는게 제한적. (어떤 동작있는지 모름) > 설계를 잘 해줘야됨 > 상속을 써야한다
  - 별도의 구동시킬 수 있는 클래스를 주면됨(인터페이스 역할-리모컨같은역할)

> 상속은 부모클래스를 잘 활용해야됨 > 부모통해 자식들 활용

* 상속관계에서 객체 생성 방법
  - 업캐스팅(부모가 자식을 가리키는 객체생성 방법) 이 가능
    ` Animal x= new Dog();
      Animal x= new Cat();`
  - 부모가 자식을 가르킴. 자식의 타입을 받아옴
  - 상속되면 Dog메모리 + Animal 메모리-자식이 생성한 객체 > 둘다 Dog사용가능

* 상속 체이닝과 super
    - 상속 체이닝 - (나보다 부모가 먼저 생성) 맨위부터 부모클래스부터 가장 자식까지 연결되는 구조
    - super() -  상위 클래스의 생성자를 호출함. 생성자 메서드에서 가장 첫 문장에 사용해야됨***  
      상위클래스의 기본생성자를 호출하는 super는 생략되어있음

  > super는 자식 클래스의 생성자에 첫머리에 와야됨! 

* 메서드의 재정의 Override 란?
    - 자식입장에서 수선해서 재정의해서 쓰는것. 상속관계에서 하위클래스가 동작을 재정의함(기능추가, 변경)
    - 동적 바인딩을 하게됨 > 실행시점에서 사용될 메서드가 결정되는 바인딩 : 자식한테 같은 메서드가 있으면 그걸 실행
      > 컴파일 시점에서는 부모건데, 실행할때 자식이 재정의를 했으면 자식 것을 실행함.
      > 부모 메서드는 그림자(무시)가됨..
    

### Ch03. 객체 형변환(Object Casting)

- 클래스 끼리 형 변환 !

* 부모와 자식 간에 형 변환이 된다
  - 부모는 여러명의 자식을 가르킬 수 있고, 부모알면 자식관리 편함
  - 업 케스팅 (자동형변환)> Animal a = new Dog(); 부모 변수 = new 자식();
  - 다운 케스팅 (강제형변환): Dog  b = (Dog)a; ((Dog)a).dogmethod;
    > 업케스팅이 되어야 다운캐스팅 할 수 있음  
    > 부모의 객체는 자식 객체타입으로 저장이 가능하다  
    > 그러나 부모객체는 자식의(자식만이 가지고있는,부모는 없는) 메서드를 호출할 수 없음.  
    > 객체, 변수 자체를 자식형으로 바꿔줘야 호출이 가능함.  

```java
 // Upcasting
Animal x=new Dog();
x.eat();

Animal x=new Cat();
//eat 는 Animal과 Cat에 전부 있고, night는 Cat에 밖에 없다면
// 다음같은 코드는 
x.night(); // >> 실행이 안됨

// 그럴때 다운 캐스팅을 해서 실행시키려면
Cat a=(Cat)x; // 형 변환을 다운캐스팅으로 해준뒤,
a.night(); //  Cat의 메서드를 호출해서 실행시키면됨.
((Cat)x).night(); //위 두줄 한줄로 쓰기   . Dot 연산자가 더 빠르게 실행되기 때문에 캐스팅을 먼저 괄호로 묶어서 실행
// 결론은 > 부모의 객체는 자식의 메서드를 호출할 수 없음. 자식형으로 바꿔줘야 호출이 가능함.

```

* 다형성 이론을 설명하기 위한 전제조건
    1. 상속관계
    2. Override(재정의)
    3. Upcasting
    4. 동적 바인딩

### Ch04. 다형성(Polymorphism)과 활용

* 다형성 이란 ?
  - 상위클래스가 동일한 메세지로 하위 클래스를 서로 다르게 동작시키는 객체지향 이론
  - 부모의 메서드를 호출했을때 자식(클래스)의 타입에 따라 다르게 나타남
  - 부모가 메서드를 호출해야(메세지를 보내야) 다형성 이라는 것이 존재함
    massage polymorphism 이라고 볼 수 있음

* 객체지향 프로그램 (oop)
   특징 : 정보은닉, 상속, 다형성

>  - Overloading(오버로딩) 정적 바인딩 : 컴파일 시점에서 사용될 메서드가 결정되는 바인딩  
>    실행속도와는 무관
>  - Override(재정의) 동적 바인딩 : 실행시점에서 사용될 (호출될) 메서드가 결정되는 바인딩  
>    실행속도와 관계가 있음(시간이 길어지는 원인이 될 수도 있다. 안될 수도 있음)
  

* 다형성 활용(다형성 인수)
  : 부모를 활용하자!
  : 여러가지 타입의 자식타입을 부모타입으로 표시(Dog 객체, Cat 객체 들 전부 부모타입 Animal ani로 표시해버리기)
  ```java
  public static void display(Dog d){
  d.eat();
  }
  public static void display(Cat c){
  c.eat();
  }
  ```
  이런 코드는
  ```java
  public static void display(Animal ani){
  ani.eat();
  }
  ```
  이렇게 표기할 수 잇다.
  ```java
  public static void display(Animal ani){
  ani.eat();
  ani.night(); //오류 > 안나게 하려면 Cat타입에만 있는 night 임으로 if 문 안에 넣어서 실행
  // 아래와 같이 바꾸기
  if(ani instanceof Cat){
  ((Cat)ani).night(); // . Dot 연산자가 더 빠르게 실행되기 때문에 캐스팅을 먼저 괄호로 묶어서 실행
  }// A instanceof B: A타입이 B인가?  True of False로 나오는 타입확인 연산자  
  }
  ```


### Ch05. 추상클래스와 인터페이스의 등장




### Ch06. 자바 최상위 클래스 Object

