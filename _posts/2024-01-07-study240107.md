---
layout: single
published: true
title:  "자바 객체지향개념2-2 (feat. 자바의 정석 기초편CH07)"
---




<br>


- [ ] 1. 자바의 정석 기초편 및 자바의 정석 (약 52+16시간 강의)
- [ ] 2. 알고리즘 공부 및 문제풀기 (약 85시간 강의)
- [ ] 2. 컴퓨터 공학 지식(약 85시간 강의)
- [ ] 3. HTML& CSS
- [ ] 3. JavaScript, Web
- [ ] 4. Spring, SQL -스프링의 정석
- [ ] 4. Spring boot - 스프링부트의 정석
- [ ] 5. 자바 프로젝트 심화
- [ ] 5. git과 깃허브
- [ ] 6. JavaScript 심화
- [ ] 7. 개인프로젝트 및 심화과정

<br>


1번 과정 : 1월 2주동안  
2번 과정 :  1월 남은 2주 
3번 과정 :  들어가기 전까지  
4번 과정 : 2월동안


<br>



## 목차

- [Quiz 및 암기 할 것 모음집](#quiz-및-암기-할-것-모음집)




## Quiz 및 암기 할 것 모음집


<details>
  <summary>
    Quiz 로 복습, 암기하기
  </summary>
<div markdown="1">

  <br>


1. 참조변수 형변환은 왜하나요?
2. instanceof 연산자는 언제 사용하나요?

  
  <br>



<details>
  <summary>
    답안지
  </summary>

<div markdown="1">
  <br>
  
1. 참조변수를 변경함으로써 사용할 수 있는 멤버의 갯수를 조절
2. 참조변수의 형변환 가능 여부 확인할때



</div>
</details>


</div>
</details>

## CH07 - 객체지향개념


### 참조변수의 형변환

 - 사용할 수 있는 멤버의 갯수를 조절하는 것 > 리모컨만 변경
 - 주소값, 객체 하나도 안바뀜
 - 조상 자손 관계의 참조변수만 서로 형변환 가능(상속관계만 가능)


 - 조상타입으로 형변환 생략가능, 자손타입으로 형변환 생략 불가
 - 상속관계 아니면 클래스간 형변환 불가.


 - 실제 객체가 중요함. 실체 객체가 5개인데 7개인 리모컨을 사용할 수는 없음
 - 실체객체의 멤버에 따라서 가능한 리모컨이 달라짐
 - 예를 들면 객체가 Car 멤버 4개 인데 Ambulance(자손 멤버 5개)가 리모컨이 될 수는 없음 


### instanceof 연산자

 * instanceof 연산자
   : 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환
   : 확인할 때 ! instanceof 사용

   ```java
   void doWork(Car c){
     if( c instanceof FireEngine){
       FireEngine fe=(FireEngine)c;
       fe.water();
   }
   }
   ```
   
- FireEngine이 Car 의 자손이면, Car는 언제나 Object의 자손임으로,
- `FireEngine fe= new FireEngine();` 일때,
- `fe instanceof (Car, Object, FireEngine)` 뭐가 와도 true
- 조상에 대해서는 전부 true여서 형변환 가능할때는 전부 true. 




### 매개변수의 다형성

 - 매개변수의 다형성
   : 참조형 매개변수는 메서드 호출 시 , 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.

 - 부모타입 매개변수로 여러 자손타입의 인스턴스들을 다룰 수 있다. (특히 뭐가 올지 모를때)
 - 예시로, Tv, computer, Desk 등 여러 물건을 샀을때 Product로 부모로 묶어서 표현 할 수 있다.

> b.buy(new Tv1()) 이런식으로 참조변수없이 객체를 바로 넣을수 있음
> 다만 이렇게 했을때 리모컨이 없어서 메서드나 멤버를 사용 불가.(객체 사용 불가)


   < 다형성의 장점>
    - 다형적 매개변수
    - 하나의 배열로 여러종류 객체 다루기

< 다형성 배운내용 정리 >
1. Tv t= new SmartTv();
2. 참조변수의 형변환 - 리모컨 바꾸기
3. instanceof연산자 - 형변환 가능여부 확인


 * 여러종류의 객체를 배열로 다루기
   : 조상타입의 배열에 자손들의 객체를 담을 수 있다.
   

`                    `             >      `Product p[] = new Product[3]`  
`Product p1 = new Tv();`           >   `p[0] = new Tv();`  
`Product p2 = new Computer();`     >   `p[1] = new Computer();`  
`Product p2 = new Audio();`        >   `p[2] = new Audio();`  



### 추상 클래스

 * 추상클래스
   : 미완성 설계도.  미완성 메서드를 갖고 있는 클래스

   - 추상 메서드를 갖고 있는 클래스 - 추상메서드 : 구현부가 없는 메서드(선언부만 있음)
   - `abstract`라는 키워드를 붙임
   - 다른클래스 작성에 도움을 주기 위한것. 객체(인스턴스) 생성 불가!
   - 상속을 통해 추상 메서드를 완성해야 객체(인스턴스) 생성가능!


 * 추상메서드
   : 미완성 메서드. 구현부(몸통 {} ) 가 없는 메서드

   - `abstract 리턴타임 메서드이름();`
   - 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우
   - 추상메서드 호출가능(소출할때는 선언부만 필요) > 나중에 몸통을 만들면
   - 인스턴스 메서드에는 무조건 호출가능(인스턴스메서드는 무조건 객체가 만들어져야 쓸수 있기 때문)
   - 구현부(자손)랑 객체가 있어야 호출이 되는거이긴함.
   - abstract를 써서 해당메서드를 오버라이딩하게 강제하는 기능도 함.



### 추상 클래스의 작성

 - 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나, 기존 클래스의 공통부분을 뽑아서 추상클래스를 만듬.

```java
Unit[] group = new Unit[3];
group[0] = new Marine();
group[1] = new Tank();
group[2] = new Dropship();

// 를 줄여서
Unit[] group= {new Marine(), new Tank(), new Dropship()}
//이렇게 한줄로 만들 수 있음
```

- 추상화 < - > 구체화
- 추상화된 코드는 구체화된 코드보다 유연함. 변경에 유리!



### 인터페이스

 * 인터페이스
   : 추상메서드의 집합

































































































